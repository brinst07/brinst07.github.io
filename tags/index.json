[{"content":"cron이란? 특정한 시간, 특정 시간 마다 어떤 작업을 수행하게 해줘야 할때 사용하는 명령어이다.\n스케줄러 같은 개념이라고 생각하면 된다.\n임시파일이나, log 파일 같이 계속 냅두면 처치하기 곤란한 파일들을 cron을 사용하게 쉽게 처리할 수 있다.\nlog같은 파일은 00시에 catlina 파일을 현재 날짜로 복제하고 원본파일은 로그를 삭제하는 방식으로 진행한다면\nlog 파일이 계속 커지지 않고 날짜별로 분류해서 확인할 수 있을 것이다.\n리눅스에서 이러한 작업들을 cron으로 진행한다고 보면 된다.\n또한 백업을 진행해야 한다고 할때 보통 새벽에 진행하게 되는데, cron이 없다면 개발자가 새벽에 출근하여\n이 작업을 진행해야 할것이다. 하지만 cron이 있다면 새벽에 출근하지 않아도 백업을 진행할 수 있다.\ncron의 동작방식, cron 실행 흐름 cron파일이 데몬이기 때문에 부팅시 백그라운드로 실행된다.\ncron 동작방식을 보면 cron 데몬(crond)가 crontab을 참조하고 있다.\ncron 데몬은 어떤 task를 언제 수행할지 crontab에서 찾아서 실행한다.\ncron 데몬은 시스템 스케줄러 정보뿐만 아니라 각각 사용자가 설정한 작업 예약 정보도 crontab에서 확인한다.\ncron의 정규 표현식    필드명 값의 허용 범위 허용된 특수문자     초(Seconds) 0~59 , - * /   분 (Minutes) 0~59 , - * /   시 (Hours) 0~23 , - * /   일 (Day) 1~31 , - * ? / L W   월 (Month) 1 ~ 12 or JAN ~ DEC , - * /   요일 (Week) 0 ~ 6 or SUN ~ SAT , - * ? / L #   연도 (Year) empty or 1970 ~ 2099 , - * /    Cron 표현식 - 특수문자 ● * : 모든 값을 뜻합니다.\n● ? : 특정한 값이 없음을 뜻합니다.\n● - : 범위를 뜻합니다. (예) 월요일에서 수요일까지는 MON-WED로 표현\n● , : 특별한 값일 때만 동작 (예) 월,수,금 MON,WED,FRI\n● / : 시작시간 / 단위 (예) 0분부터 매 5분 0/5\n● L : 일에서 사용하면 마지막 일, 요일에서는 마지막 요일(토요일)\n● W : 가장 가까운 평일 (예) 15W는 15일에서 가장 가까운 평일 (월 ~ 금)을 찾음\n● # : 몇째주의 무슨 요일을 표현 (예) 3#2 : 2번째주 수요일\ncrontab 파일의 7필드 m h dom mon dow user command    필드 설정 값 및 내용     m 분을 나타내고, 0~59로 설정한다.   h 시을 나타내고, 0~23으로 설정한다.   dom 날을 나타내고, 1~31로 설정한다.   mon 월을 나타내고, 1~12로 설정한다.   dow 요일을 나타내고, 0~7로 설정한다. 0과 7은 일요일에 해당하고 1은 월요일임   user user-name 사용자 이름   command 실행할 명령어를 기입한다. 명령어 앞에 사용자 이름을 써도 된다.     \u0026lsquo;*\u0026rsquo; : 각 필드 자리에 * 기호가 오면 해당 필드의 모든 값을 의미한다. \u0026lsquo;-\u0026rsquo; : 그 사이의 모든 값 \u0026lsquo;,\u0026rsquo; : 지정한 모든 값을 의미(불규칙한 값 지정시 주로 사용) \u0026lsquo;/\u0026rsquo; : \u0026lsquo;/\u0026lsquo;는 연결된 설정 값 범위에서 특정 주기로 나눌 때 사용한다.  Cron 예시 01 * * * * root run-parts /etc/cron.hourly #매일 매시 1분에 root 권한으로 /etc/cron.hourly 내 모든 스크립트를 실행한다.\r02 4 * * * root run-parts /etc/cron.daily # 매일 새벽 4시 2분에 /etc/cron.daily 내 모든 작업을 실행한다.\r# 2분으로 한 것은 매 1분에는 시간별 작업이 실행되기 때문이다.\r22 4 * * 0 root run-parts /etc/cron.weekly # 매주 일요일(0) 4시 22분에 주간 작업들을 실행한다.\r42 4 1 * * root run-parts /etc/cron.monthly # 매월 1일 4시 42분에 월간 작업들을 실행한다.\rCronMaker 참고 사이트 http://www.cronmaker.com/;jsessionid=node068maia8exxmw1ia839g15hrpk46275.node0?0\n","description":"","id":0,"section":"posts","tags":null,"title":"cron","uri":"https://brinst07.github.io/posts/etc/test1-copy/"},{"content":"리사이클러뷰  리사이클러뷰는 스피너가 조금 더 확장된 형태이다. 리사이클러뷰도 스피너처럼 목록을 화면에 출력하는데, 레이아웃 매너지를 이용하면 간단한 코드만으로 일반 리스트뷰를 그리드뷰로 바꿀 수 도 있다. 리사이클러뷰처럼 목록을 표시하는 컨테이너들은 표시될 데이터와 아이템 레이아웃을 어댑터에서 연결해주므로 어댑터에서 어떤 아이템 레이아웃을 사용하느냐에 따라 표시되는 모양을 다르게 만들 수 있다.  매커니즘   원하는 액티비티에 리사이클러뷰 만들기\n  리사이클러에 뿌릴 Model(dto) 만들기\n  어댑터 정의하기\n  리사이클러뷰는 리사이클러 어댑터라는 메서드 어댑터를 사용해서 데이터를 연결한다.\n  리사이클러뷰 어댑터는 개별 데이터에 대응하는 뷰홀더 클래스를 사용한다.\n1 2 3 4 5  class customAdapter : RecyclerView.Adapter\u0026lt;ViewHolder\u0026gt;{ override fun onBindViewHolder(viewholder, item){ } }     뷰홀더는 현재 홤녀에 보여지는 개수만큼만 생성되고 목록이 위쪽으로 스크롤 될 경우 가장 위의 뷰홀더를 아래에서 재사용한 후 데이터만 바꿔주기 때문에 앱의 효율이 향상됨.\n    ","description":"","id":1,"section":"posts","tags":null,"title":"RecyclerView","uri":"https://brinst07.github.io/posts/kotlinandroid/recyclerview/"},{"content":"영속성 관리  JPA에서 가장 중요한 2가지  객체와 관계형 DB 매핑하기 - 설계 관련 영속성 컨텍스트 - JPA 내부동작    엔티티 매니저 팩토리와 엔티티 매니저  JPA는 스레드가 하나 생성될 때 마다 EntityManagerFactory에서 EntityManager를 생성한다. EntityManager는 내부적으로 DB 커넥션 풀을 사용해서 DB에 붙인다.  영속성 컨텍스트  엔티티를 영구저장하는 환경이라는 뜻 EntityManger.presist(entity)  persist()를 하면 실제로는 DB에 저장하는 것이 아니라, 영속성 컨텍스트를 통해서 엔티티를 영속화 한다. persist() 시점에는 영속성 컨텍스트에 저장한다. DB저장은 나중임\u0026hellip;.    엔티티의 생명주기  비영속  영속성 컨텍스트와 전혀 관계가 없는 상태   //객체를 생성한 상태 (비영속)\rMember member = new Member();\rmember.setId(\u0026quot;member1);\rmember.setUsername(\u0026quot;회원1\u0026quot;)\r 영속  영속성 컨텍스트에 저장된 상태 엔티티가 영속성 컨텍스트에 의해 관리된다. 이때 DB에 저장 되지 않는다. 영속 상태가 된다고 DB에 쿼리가 날아가지 않는다. 트랜잭션의 커밋 시점에 영속성 컨텍스트에 있는 정보들이 DB에 쿼리로 날아간다.   // 객체를 생성한 상태 (비영속)\rMember member = new Member();\rmember.setId(\u0026quot;member1\u0026quot;);\rmember.setUsername(\u0026quot;회원1\u0026quot;);\rEntityManager entityManager = entityManagerFactory.createEntityManager();\rentityManager.getTransaction().begin();\r// 객체를 저장한 상태 (영속)\rentityManager.persist(member);\r EntityManager.persist(entity)  영속상태가 된다고 바로 DB에 쿼리가 날아가지 않는다. (즉, DB 저장 X)   transaction.commit()  트랜잭션의 commit 시점에 영속성 컨텍스트에 있는 정보들이 DB에 쿼리로 날아간다.     준영속  영속성 컨텍스트에 저장되었다가 분리된 상태 영속성 컨텍스트에서 지운 상태   //회원 엔티티를 영속성 컨텍스트에서 분리, 준영속 상태\rentityManger.detach(member);\r 삭제  삭제된 상태. DB에서도 날린다.   //객체를 삭제한 상태\rentityManager.remove(member);\r  영속성 컨텍스트의 이점  Application과 DB 사이의 중간 계층의 영속성 컨텍스트가 존재하는 이유  버퍼링, 캐싱 등의 이점    1. 1차 캐시   영속성 컨텍스트 내부에는 1차 캐시가 존재한다.\n 1차 캐시를 영속성 컨텍스트라고 이해해도 됨    Map\u0026lt;Key,Value\u0026gt; 로 1차 캐시에 저장된다.\n key : @Id로 선언한 필드값 (DB pk) value : 해당 객체   Member member = new Member();\rmember.setId(\u0026quot;brinst\u0026quot;);\rmember.setUsername(\u0026quot;brinst1\u0026quot;)\r// 영속상태 (Persistence Context에 의해 Entity가 관리되는 상태)\r// DB 저장 X, 1차 캐시에 저장됨\rentityManager.persist(member);\r// 1차 캐시에서 조회\rMember brinst = entityManager.find(Member.class,\u0026quot;brinst\u0026quot;);\r 1차 캐시에 Entity가 있을 때의 이점  조회 entityManager.find()를 하면 DB보다 먼저, 1차 캐시를 조회한다. 1차 캐시에 해당 Entity가 존재하면 바로 반환한다. 1차 캐시에 조회하고자 하는 Entity가 없다면?  DB에서 조회한다. 해당 Entity를 DB에서 꺼내와 1차 캐시에 저장한다. Entity를 다시 반환한다. 이후에 다시 해당 Entity를 조회하면 1차 캐시에 있는 Entity를 반환한다.   그러나, 사실 1차 캐시는 큰 성능 이점을 가지고 있지 않다.  EntityManager는 Transaction 단위로 만들고, 해당 DB Transaction이 끝날 때(사용자의 대한 요청에 대한 비지니스가 끝날 때) 같이 종료된다. 즉, 1차 캐시도 모두 날아가기 때문에 굉장히 짧은 찰나의 순간에만 이득이 있다.(DB의 한 Transaction 안에만 효과가 있다.) 하지만, 비지니스 로직이 굉장히 복잡한 경우에는 효과가 있다.        2. 동일성 보장(Identity) Member a = entityManager.find(Member.class, \u0026quot;member1\u0026quot;);\rMember b = entityManager.find(Member.class, \u0026quot;member1\u0026quot;);\ra == b -\u0026gt; true\r 영속 Entity의 동일성(== 비교)을 보장한다.  즉, \u0026ldquo;==\u0026rdquo; 비교가 true임을 보장한다. member1에 해당하는 Entity를 2번 조회하면 1차 캐시에 의해 같은 Reference로 인식된다. 하나의 Transaction안에서 같은 Entity 비교시 true    3. 엔티티 \u0026ldquo;등록\u0026rdquo; 시 트랜잭션을 지원하는 쓰기 지연(Transactional Write-Behind) EntityManager entityManager = emf.createEntityManager();\rEntityTransaction transaction = entityManager.getTransaction();\r// EntityManager는 데이터 변경 시 트랜잭션을 시작해야 한다.\rtransaction.begin(); // Transaction 시작\rentityManager.persist(memberA);\rentityManager.persist(memberB);\r//이때 까지 Insert SQL을 DB에 보내지 않는다.\r//커밋하는 순간 DB에 INSERT SQL을 보낸다.\rtransaction.commit();\r entityManager.persist()  JPA가 insert SQL을 계속 쌓고 있는 상태   transaction.commit()  커밋하는 시점에 insert SQL을 동시에 DB에 보낸다. 동시에 쿼리들을 보냄(쿼리를 보내는 방식은 동시 or 하나씩 옵션에 따라 다름)   entityManager.persist(memberA)  memberA가 1차 캐시에 저장된다. 1과 동시에 JPA가 Entity를 분석하여 insert Query를 만든다. insert Query를 쓰기 지연 SQL 저장소라는 곳에 쌓는다. DB에 바로 넣지 않고 기다린다.   transaction.commit()  쓰기 지연 SQL 저장소에 쌓여 있는 Query들을 DB로 날린다. (flush)  **flush()**는 1차캐시를 지우지는 않는다. 쿼리들을 DB에 날려서 DB와 싱크를 맞추는 역할을 한다.   flush() 후에 실제 DB Transaction이 커밋된다.    4. 엔티티 \u0026ldquo;수정\u0026quot;시 변경 감지(Dirty Checking) EntityManager em = emf.createEntityManaer();\rEntityTransaction transaction = em.getTransaction();\rtransaction.begin(); //트랜잭션 시작\r//영속 엔티티 조회\rMember memberA = em.find(Member.class, \u0026quot;memberA\u0026quot;);\r//영속 엔티티 데이터 수정\rmemberA.setUsername(\u0026quot;hi\u0026quot;);\rmemberA.setAge(10);\rtransaction.commit();\r Entity 데이터 수정 시 update()나 persist()로 영속성 컨텍스트에 해당 데이터를 업데이트 해달라고 알려줘야 할 필요가 없다. Entity 데이터만 수정하고 commit 하면 알아서 DB에 반영됨 즉, 데이터를 set하면 해당 데이터의 변경을 알아서 감지하여 자동으로 UPDATE Query가 나가는 것이다.  변경 감지(Dirty Checking)  1차 캐시  @Id, Entity, Snapshot (값을 읽어온 최초의 상태) Snapshot : 영속성 컨텍스트에 최초로 값이 들어왔을 때의 상태값을 저장한다.   변경 감지 매커니즘  transaction.commit()을 하면  flush()가 일어날 때 엔티티와 스냅샷을 일일이 비교한다. 변경사항이 있으면 UPDATE Query를 만든다. 해당 UPDATE Query를 쓰기 지연 SQL 저장소에 넣는다. UPDATE Query를 DB에 반영한 후 commit()한다.      5. 엔티티 삭제  Member memberA = em.find(Member.class,\u0026quot;memberA\u0026quot;);\rem.remove(memberA); //엔티티 삭제\r 위의 Entity 수정에서의 매커니즘과 동일 Transaction의 commit 시점에 DELETE Query가 나간다.  플러시(flush)  영속성 컨텍스트의 변경 내용을 DB에 반영하는 것을 말한다. Transaction commit이 일어날 때 flush가 동작하는데, 이때 쓰기 지연 저장소에 쌓아놨던 INSERT, UPDATE, DELETE SQL 들이 DB에 날아간다. -\u0026gt; 영속성 컨텍스트를 비우는 것이 아님 영속성 컨텍스트의 변경사항들과 DB의 상태를 맞추는 작업  플러시는 영속성 컨텍스트의 변경 내용을 DB에 동기화 한다.    플러시의 동작 과정  변경을 감지한다. (Dirty Checking) 수정된 Entity를 쓰기 지연 SQL 저장소에 등록한다. 쓰기 지연 SQL 저장소의 Query를 DB에 전송한다.  flush가 발생한다고 해서 commit이 이루어지는 것이 아니고 flush 다음에 실제 commit이 일어난다. flush가 동작할 수 있는 이뉴는 데이터베이스 트랜잭션(작업 단위)이라는 개념이 있기 때문이다.  트랜잭션이 시작되고 해당, 트랜잭션이 commit 되는 시점 직전에만 동기화(변경 내용을 날림) 해주면 되기 때문에, 그 사이에서 플러시 매커니즘의 동작이 가능한 것이다.      영속성 컨텍스트를 플러시 하는 방법 1. em.flush()을 통한 직접 호출 // 영속 상태(Persistence Context에 의해 Entity가 관리되는 상태)\rMember member = new Member(200L,\u0026quot;A\u0026quot;);\rentityManager.persist(member);\rentityManager.flush(); // 강제 호출(쿼리가 DB에 반영됨)\rtx.commit(); //DB에 insert query가 날아가는 시점(Transaction commit)\r 플러시가 일어나면 1차 캐시가 모두 지워질까?  그대로 남아있음 쓰기 지연 SQL 저장소에 있는 Query들만 DB에 전송까지만 되는 과정일 뿐임    2. 트랜잭션 커밋 시 플러시 자동 호출 3. JPQL 쿼리 실행 시 플러시 자동 호출 em.persist(memberA);\rem.persist(memberB);\rem.persist(memberC);\r// 중간에 JPQL 실행\rquery = entityManager.createQuery(\u0026quot;select m from Member m\u0026quot;,Member.class);\rList\u0026lt;Member\u0026gt; members = query.getResultList();\r member A,B,C 를 영속성 컨텍스트에 저장한 상태에서 바로 조회하면 조회가 될까?  조회가 되지 않는다. DB에 Query로도 날아가야 반영이 될텐데 INSERT Query 자체가 날아가지 않은 상태이다. 이 때문에 JPA의 기본모드는 JPQL 쿼리 실행시 flush()를 자동으로 날린다. -\u0026gt; JPQL 쿼리 실행시 플러시 자동 호출로 인해 위 코드는 조회가 가능하다.    ","description":"","id":2,"section":"posts","tags":null,"title":"JPA 영속성 컨텍스트와 플러시","uri":"https://brinst07.github.io/posts/javaspringboot/jpa%EC%98%81%EC%86%8D%EC%84%B1%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/"},{"content":"다시 살린 블로그 과거에 있던 블로그가 삭제되어서 새롭게 블로그를 다시 만들었다.\n이 블로그에 다시 개발 관련 생각이나, 배운 지식들을 정리하고자 한다.\n2021년도의 계획  스프링부트로 나만의 웹서버 개발하기\n1.1 JPA 숙지하기\n1.2 스프링 부트 숙지하기\n1.3 리액트 숙지하기\n1.4 리액트 숙지 후 더 나아가 리액트 하이브리드 웹앱도 도전해보자 코틀린 + 안드로이드로 나만의 웹을 개발하기\n2.1 firebase 숙지\n2.2 코틀린 문법숙지\n2.3 안드로이드 숙지하기 ios 개발 도전????\n맥북을 구입하게 된다면 ios에도 한번 도전해보자  스프링부트 스터디  계획\n스프링 스터디원들과 함께 JPA react SpringBoot 환경으로 웹사이트 제작 주제\n미정  안드로이드 스터디  계획\n스터디원들과 함께 kotlin을 base로 한 앱을 개발한다. 주제\n토닥토닥 -\u0026gt; 게시판 위주의 앱이 될듯 하다. 기능\n3.1 소셜 로그인\n3.2 firebase를 기반으로 한 CRUD\n3.3 채팅기능\n3.4 결제기능  ","description":"","id":3,"section":"posts","tags":null,"title":"Come Back!!!","uri":"https://brinst07.github.io/posts/etc/test1/"}]