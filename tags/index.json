[{"content":"연관관계와 관계형 데이터 베이스 설계 관계형 데이터베이스에서는 개체 간의 관계라는 것에 대해 고민하게 된다.\n관계형 데이터베이스에서는 일대일(1:1), 일대다(1:N), 다대다(M:N)의 관계를 이용해서 데이터가 서로 간에 어떻게 구성되었는지를 표현한다.\n위 관계를 가장 쉽게 확인할 수 있는 방법은 직접 가상의 데이터를 만들어 보는 것이다.\n데이터베이스에서 관계를 해석할 때는 항상 PK쪽에서 해석한다.\nJPA에서 연관관계 해석하기 JPA를 이용해서 연관관계를 해석할 때는 PK를 기준으로 잡고, 데이터베이스를 모델링하는 방식으로 구성한다.\n엔티티 생성하기 1 2 3 4 5 6 7 8 9 10 11 12 13 14  @Entity @Builder @AllArgsConstructor @NoArgsConstructor @Getter @ToString public class Member extends BaseEntity{ @Id private String email; private String password; private String name; }   Member 클래스 이메일 주소를 PK로 이용한다. 데이터베이스 설게에서도 member 테이블은 PK만을 가지고 있고, FK를 사용하지 않으므로 별도의 참조가 필요하지 않는다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  @Entity @Builder @AllArgConstructor @NoArgsConstructor @Getter @ToString public class Board extends BaseEntity{ @Id @GeneratedValue(strategy = GeneationType.IDENTITY) private Long bno; private String title; private String content; @ManyToOne private Member writer; // 연관관계 지정 }   @ManyToOne 어노테이션 데이터베이스 구조로 보면 board 테이블과 member 테이블에는 FK를 이용한 참조가 걸려 있게 된다.\nJPA에서 관계를 고민할 때는 FK 쪽을 먼저 해석해보면 편리하다.\nboard와 member의 관게는 N:1(다대일)의 관계가 되므로 JPA에서는 이를 의미하는 @ManyToOne을 적용해야 한다.\n@ManyToOne은 데이터베이스상에서 외래키의 관계로 연결된 엔티티 클래스에 설정한다.\n@ManyToOne과 Eager/Lazy Loading 두개 이상의 엔티티 간의 연관관계를 맺고 나면 데이터베이스 입장에서는 연관관계를 맺고 있기 때문에 조인이 필요하다고 생각한다.\n실제로 @ManyToOne의 경우에는 FK 쪽의 엔티티를 가져오때 PK 쪽의 엔티티도 같이 가져온다.\n따라서 연관관계에 있는 값을 가져오려면 자동적으로 조인이 된다.\n조인이 필요없을 때도 조인이 발생하기 때문에 시스템의 비효율을 야기할 수 있다.\n그래서 fetch는 Lay loading을 권장한다.\n위 처럼 쿼리 실행결과와 같이 특정한 엔티티를 조회할때 연관관계를 가진 모든 엔티티를 같이 로딩하는 것을 Eager loading이라고 한다. 이는 즉시 로딩이라는 말로도 표현하기도 한다.\nJPA에서 연관관계를 데이터를 어떻게 가져올 것인가를 fetch(패치)라고 하는데 연관관계의 어노테이션의 속성으로 fetch 모드를 지정한다.\n즉시 로딩은 불필요한 조인까지 처리해야 하는 경우가 많기 때문에 간으하면 사용하지 않고, 그와 반대되는 개념으로 Lazy loading으로 처리한다. 이는 지연 로딩이라고 부르기도 한다.\n지연로딩을 사용하게 되면 즉시로딩보다는 확실히 효율적으로 값을 가져올 순 있지만, 단점 또한 존재한다.\n1 2 3 4 5  Board board = result.get(); System.out.println(board); xxxx 오류 발생 xxxx System.out.println(board.getWriter());   위 코드를 지연로딩을 사용해서 수행하면 오류가 발생한다.\nboard.getWriter는 member 테이블을 로딩해야 하는데 이미 데이터베이스와의 연결이 끝났기 때문에 에러가 발생한다.\n이러한 상황으로 보아 지연로딩은 단순하게 하나의 테이블을 이용하는 경우에는 빠른 속도의 처리가 가능하다는 장점이 있지만, 연관관계가 복잡한 경우에는 여러 번의 쿼리가 실행된다는 단점이 있다.\n따라서 보편적인 코딩 가이드는 지연로딩을 기본으로 사용하고, 상황에 맞게 필요한 방법을 찾는다 이다.\n이때 @Transactional을 사용하면 에러를 해결할 수 있다.\n@Transactional은 해당 메서드를 하나의 트랜잭션으로 처리하라는 의미이다.\n연관관계에서는 @ToString()을 조심 @ToString()을 사용하게 되면 해당 클래스의 모든 멤버변수를 출력하게 된다. 예를 들어 Board객체의 TosString을 하려면 Member도 호출해야하는 것이다.\n따라서 연관관계가 있는 엔티티 클래스의 경우 @ToString()을 할 때는 습관적으로 exclude 속성을 사용하는 것이 좋다.\n","description":"","id":0,"section":"posts","tags":null,"title":"JPA N:1(다대일) 연관관계","uri":"https://brinst07.github.io/posts/javaspringboot/n1/"},{"content":"TabLyaout tablayout이란 상단에 탭을 클릭하면 화면이 전환되는 것을 말한다.\n상단의 탭을 클릭해도 하단의 fragment가 전환되어야하고 fragment를 스와이프 해도 상단의 탭이 전환되어야한다.\n구현 gradle에 추가하기  implementation 'com.android.support:design:30.0.0' gradle에 다음을 추가해준다.\n ","description":"","id":1,"section":"posts","tags":null,"title":"tabLayout","uri":"https://brinst07.github.io/posts/kotlinandroid/viewpager-copy/"},{"content":"viewPager란? 배달의 민족이나 어플들을 사용하면 상단의 그림들이 스와이프 하면 넘어가거나 한것을 볼수 있었을 것이다. 그것을 구현하기 위한 것이 바로 viewPager이다.\n구현방법 액티비티에 viewPager 만들기 아래 코드 처럼 viewPager를 xml에 추가한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; \u0026lt;androidx.viewpager.widget.ViewPager android:id=\u0026#34;@+id/viewPager\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;220dp\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; /\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt;   layout 만들기 listView나 viewpager나 그 안에 들어가는 layout아이템을 만들어서 adapter에 넣는 방식으로 진행이 되는 것같다.\n아직 안드로이드 초보라서 모르겠지만 지금까지 파악한 개념으로는 해당액티비에 pager든 view를 만들어서 어댑터를 만들고 그안에 dto나 데이터를 넣어 kt파일에서 결합하는 방식으로 진행이 되는거같다.\n하단처럼 진행을 했고 맨처음에 constaintLayout으로 만들어지지만 LinearLayout으로 변경하여 만들었다.\n1 2 3 4 5 6 7 8 9 10 11  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;ImageView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;220dp\u0026#34; android:id=\u0026#34;@+id/imageview\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt;   adapter만들기 다음은 어댑터를 만든다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  package com.brinst.comin import android.content.Context import android.view.LayoutInflater import android.view.View import android.widget.ImageView import androidx.viewpager.widget.PagerAdapter import androidx.viewpager.widget.ViewPager class ViewPagerAdapter(private val context: Context) : PagerAdapter(){ private var layoutInflater : LayoutInflater? = null val Image = arrayOf( R.drawable.ai, R.drawable.css, R.drawable.html ) override fun getCount(): Int { return Image.size } override fun isViewFromObject(view: View, `object`: Any): Boolean { return view === `object` } override fun instantiateItem(container: View, position: Int): Any { layoutInflater = context.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater val v = layoutInflater!!.inflate(R.layout.viewpager_activity,null) val image = v.findViewById\u0026lt;View\u0026gt;(R.id.imageview) as ImageView image.setImageResource(Image[position]) val vp = container as ViewPager vp.addView(v,0) return v } override fun destroyItem(container: View, position: Int, `object`: Any) { val vp = container as ViewPager val v = `object` as View vp.removeView(v) } }   위와 같은 코드로 구성이 되는데 메소드의 대한 상세설명은 다음과 같다.\n   함수 설명     instantiateItem(ViewGroup view, int position) 데이터 리스트에서 인자로 넘어온 position에 해당하는 아이템 항목에 대한 페이지를 생성합니다.   destroyItem(ViewGroup parent, int position, Object object) Adapter가 관리하는 데이터 리스트에서 인자로 넘어온 position에 해당하는 데이터 항목을 생성된 페이지를 제거   int getCount() Adapter가 관리하는 데이터 리스트의 총 개수   isViewFromObject(View view, Object object) 페이지가 특정 키와 연관되는지 체크    MainAcitivy에서 구현 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  package com.brinst.comin import android.content.Intent import androidx.appcompat.app.AppCompatActivity import android.os.Bundle import androidx.viewpager.widget.ViewPager import kotlinx.android.synthetic.main.activity_main.* class MainActivity : AppCompatActivity() { internal lateinit var viewpager : ViewPager override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) //viewpager  viewpager = findViewById(R.id.viewPager) as ViewPager val adapter = ViewPagerAdapter(this) viewpager.adapter=adapter //end viewpager  } }   ","description":"","id":2,"section":"posts","tags":null,"title":"viewpage","uri":"https://brinst07.github.io/posts/kotlinandroid/viewpager/"},{"content":"cron이란? 특정한 시간, 특정 시간 마다 어떤 작업을 수행하게 해줘야 할때 사용하는 명령어이다.\n스케줄러 같은 개념이라고 생각하면 된다.\n임시파일이나, log 파일 같이 계속 냅두면 처치하기 곤란한 파일들을 cron을 사용하게 쉽게 처리할 수 있다.\nlog같은 파일은 00시에 catlina 파일을 현재 날짜로 복제하고 원본파일은 로그를 삭제하는 방식으로 진행한다면\nlog 파일이 계속 커지지 않고 날짜별로 분류해서 확인할 수 있을 것이다.\n리눅스에서 이러한 작업들을 cron으로 진행한다고 보면 된다.\n또한 백업을 진행해야 한다고 할때 보통 새벽에 진행하게 되는데, cron이 없다면 개발자가 새벽에 출근하여\n이 작업을 진행해야 할것이다. 하지만 cron이 있다면 새벽에 출근하지 않아도 백업을 진행할 수 있다.\ncron의 동작방식, cron 실행 흐름 cron파일이 데몬이기 때문에 부팅시 백그라운드로 실행된다.\ncron 동작방식을 보면 cron 데몬(crond)가 crontab을 참조하고 있다.\ncron 데몬은 어떤 task를 언제 수행할지 crontab에서 찾아서 실행한다.\ncron 데몬은 시스템 스케줄러 정보뿐만 아니라 각각 사용자가 설정한 작업 예약 정보도 crontab에서 확인한다.\ncron의 정규 표현식    필드명 값의 허용 범위 허용된 특수문자     초(Seconds) 0~59 , - * /   분 (Minutes) 0~59 , - * /   시 (Hours) 0~23 , - * /   일 (Day) 1~31 , - * ? / L W   월 (Month) 1 ~ 12 or JAN ~ DEC , - * /   요일 (Week) 0 ~ 6 or SUN ~ SAT , - * ? / L #   연도 (Year) empty or 1970 ~ 2099 , - * /    Cron 표현식 - 특수문자 ● * : 모든 값을 뜻합니다.\n● ? : 특정한 값이 없음을 뜻합니다.\n● - : 범위를 뜻합니다. (예) 월요일에서 수요일까지는 MON-WED로 표현\n● , : 특별한 값일 때만 동작 (예) 월,수,금 MON,WED,FRI\n● / : 시작시간 / 단위 (예) 0분부터 매 5분 0/5\n● L : 일에서 사용하면 마지막 일, 요일에서는 마지막 요일(토요일)\n● W : 가장 가까운 평일 (예) 15W는 15일에서 가장 가까운 평일 (월 ~ 금)을 찾음\n● # : 몇째주의 무슨 요일을 표현 (예) 3#2 : 2번째주 수요일\ncrontab 파일의 7필드 m h dom mon dow user command    필드 설정 값 및 내용     m 분을 나타내고, 0~59로 설정한다.   h 시을 나타내고, 0~23으로 설정한다.   dom 날을 나타내고, 1~31로 설정한다.   mon 월을 나타내고, 1~12로 설정한다.   dow 요일을 나타내고, 0~7로 설정한다. 0과 7은 일요일에 해당하고 1은 월요일임   user user-name 사용자 이름   command 실행할 명령어를 기입한다. 명령어 앞에 사용자 이름을 써도 된다.     \u0026lsquo;*\u0026rsquo; : 각 필드 자리에 * 기호가 오면 해당 필드의 모든 값을 의미한다. \u0026lsquo;-\u0026rsquo; : 그 사이의 모든 값 \u0026lsquo;,\u0026rsquo; : 지정한 모든 값을 의미(불규칙한 값 지정시 주로 사용) \u0026lsquo;/\u0026rsquo; : \u0026lsquo;/\u0026lsquo;는 연결된 설정 값 범위에서 특정 주기로 나눌 때 사용한다.  Cron 예시 01 * * * * root run-parts /etc/cron.hourly #매일 매시 1분에 root 권한으로 /etc/cron.hourly 내 모든 스크립트를 실행한다.\r02 4 * * * root run-parts /etc/cron.daily # 매일 새벽 4시 2분에 /etc/cron.daily 내 모든 작업을 실행한다.\r# 2분으로 한 것은 매 1분에는 시간별 작업이 실행되기 때문이다.\r22 4 * * 0 root run-parts /etc/cron.weekly # 매주 일요일(0) 4시 22분에 주간 작업들을 실행한다.\r42 4 1 * * root run-parts /etc/cron.monthly # 매월 1일 4시 42분에 월간 작업들을 실행한다.\rCronMaker 참고 사이트 http://www.cronmaker.com/;jsessionid=node068maia8exxmw1ia839g15hrpk46275.node0?0\nShell Script  스크립트 : 텍스트 형식으로 저장되는 프로그램으로서 한줄씩 순차적으로 읽어 실행되도록 작성된 프로그램  일반적으로 인터프리트 방식으로 동작하는 컴파일되지 않은 프로그램   Shell Script : 운영체제의 쉘 즉 bash, ksh, csh 등이 읽어 실행해주는 스크립트 언어  환경  Linux 기반 시스템 Bash shell(/bin/bash)  작성방법 1 2 3  #!/bin/bash  하단에 스크립트를 작성한다.   쉘 스크립트 실행방법 ./shell_test.sh\rsh shell_test.sh\r기본 문법  출력 1 2 3  #! /bin/bash  echo \u0026#34;hello~ script\u0026#34;     위 쉘 스크립트를 실행하면 hello script 한줄을 실행한다.\n  주석 : #\n  변수선언\n =를 이용하여 선언하고 $를 이용해서 사용 =는 공백없이 붙여써야한다. 지역변수에는 local을 붙인다. \u0026ldquo;\u0026ldquo;로 감싸서 사용하면 더 안전하다. 문자열에 공백도 포함해서 값을 이용 할 수 있기 때문에  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #!/bin/bash # 변수 선언 test=\u0026#34;abc\u0026#34; num=100 #변수 사용하기 및 출력 echo ${test} echo ${num} echo \u0026#34;${test}\u0026#34; echo \u0026#34;${num}\u0026#34; #지역변수 local local_var=\u0026#34;local var\u0026#34; #변수가 선언되지 않았을 때 기본값을 지정하며 사용하는 방법 defalut_var=${default_var=\u0026#34;temp\u0026#34;}     배열\n 배열의 인덱스는 0부터 시작함 배열이름[@]는 배열의 모든 원소를 의미한다. 배열의 원소 추가 시는 += 연산자를 사용한다. 배열에서 원소를 삭제시  /를 사용해 해당 문자열 부분이 있으면 삭제, 삭제하고자 하는 문자나 문자열이 포함되어 있는 부분을 삭제 unset을 이용해 삭제    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  #!/bin/bash arr_test=(\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;) echo \u0026#34;${arr_test[1]}\u0026#34; echo \u0026#34;${arr_test[@]}\u0026#34; arr_test+=(\u0026#34;3\u0026#34;,\u0026#34;4\u0026#34;) remove_element=(3) arr_test=(\u0026#34;${arr_test[@]/$remove_element}\u0026#34;) for i in ${!arr_test[@]}; do if [ ${arr_test[i]} = ${remove_element} ]; then # Use unset unset arr_test[i] fi done     조건문\n if[조건]; then\u0026hellip; elif[조건]; then\u0026hellip;else 를 사용한다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  #!/bin/bash # Numeric if statement test_num=5 if [ \u0026#34;${test_num}\u0026#34; -eq 2 ]; then echo \u0026#34;number is 2\u0026#34; elif [ \u0026#34;${test_num}\u0026#34; -eq 3 ]; then echo \u0026#34;number is 3\u0026#34; else echo \u0026#34;number is not 2 or 3\u0026#34; fi # Numeric if statement test_num=5 if (( ${test_num} \u0026gt; 3 )); then echo \u0026#34;number is greater than 3\u0026#34; else echo \u0026#34;number is not greater than 3\u0026#34; fi # String if statement test_str=\u0026#34;test\u0026#34; if [ \u0026#34;${test_str}\u0026#34; = \u0026#34;test\u0026#34; ]; then echo \u0026#34;test_str is test\u0026#34; else echo \u0026#34;test_str is not test\u0026#34; fi     반복문\n while 문의 사용  1 2 3 4 5 6 7  #!/bin/bash cnt=0 while (( \u0026#34;${cnt}\u0026#34; \u0026lt; 5 )); do echo \u0026#34;${cnt}\u0026#34; (( cnt = \u0026#34;${cnt}\u0026#34; + 1 )) # 숫자와 변수의 연산은 (())가 필요합니다. done     for문의 사용법\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  #!/bin/bash arr_num=(1 2 3 4 5 6 7) # 배열에 @는 모든 원소를 뜻합니다. for i in ${arr_num[@]}; do printf $i done echo for (( i = 0; i \u0026lt; 10; i++)); do printf $i done echo     쉘스크립트 활용 github 블로그를 만들게 되면 submodule과 blog repository에 둘다 commit을 해야만이 정상적으로 블로그에 연동되는 것을 확인할 수 있다.\n하지만 add -\u0026gt; commit -\u0026gt; message 작성 -\u0026gt; push 이 작업을 두번이나 해주는 것이 매우 번거롭다.\n따라서 이러한 작업을 쉘 스크립트를 사용하여 간단히 처리할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  #!/bin/bash  echo -e \u0026#34;\\033[0;32mDeploying updates to GitHub...\\033[0m\u0026#34; # Build the project. hugo -t zzo # Go To Public folder cd public # Add changes to git. git add . # Commit changes. msg=\u0026#34;rebuilding site `date`\u0026#34; if [ $# -eq 1 ] then msg=\u0026#34;$1\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; # Push source and build repos. git push origin master # Come Back up to the Project Root cd .. # blog 저장소 Commit \u0026amp; Push git add . msg=\u0026#34;rebuilding site `date`\u0026#34; if [ $# -eq 1 ] then msg=\u0026#34;$1\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; git push origin master   위 쉘스크립트 코드를 보면 우리가 실제로 사용하는 git 명령어인 것을 확인 할 수 있다.\n따라서 쉘 스크립트와 cron을 사용하면 훨씬더 편하게 작업할 수 있는 것을 알 수 있다.\n","description":"","id":3,"section":"posts","tags":null,"title":"cron 과 shellscript","uri":"https://brinst07.github.io/posts/linuxsever/cronshellscript/"},{"content":"JPA란?? Java 언어를 통해서 데이터베이스와 같은 영속 계층을 처리하고자 하는 스펙\nORM과 JPA ORM  객체지향과 관련이 있음 \u0026lsquo;객체지향 패러다임을 관계형 데이터베이스에 보존하는 기술\u0026rsquo; \u0026lsquo;객체지향 패러다임을 관계형 패러다임으로 매핑해주는 개념\u0026rsquo; 관계형 데이터베이스의 테이블을 설계하여 데이터를 보관하는 틀을 만든다는 의미에서 클래스와 상당히 유사함\njava\rsql\r\r1 2 3 4 5  public class Member{ private String id; private String pw; private String name; }   \r 1 2 3 4  Member id -\u0026gt; varchar2(50) pw -\u0026gt; varchar2(50) name -\u0026gt; varchar2(100)   \r \r\r'use strict';\rvar containerId = JSON.parse(\"\\\"60340c9be0e6527c\\\"\");\rvar containerElem = document.getElementById(containerId);\rvar codetabLinks = null;\rvar codetabContents = null;\rvar ids = [];\rif (containerElem) {\rcodetabLinks = containerElem.querySelectorAll('.codetab__link');\rcodetabContents = containerElem.querySelectorAll('.codetab__content');\r}\rfor (var i = 0; i 0) {\rcodetabContents[0].style.display = 'block';\r}\r   클래스와 테이블이 유사하듯이 \u0026lsquo;인스턴스\u0026rsquo;와 \u0026lsquo;Row\u0026rsquo;도 상당히 유사함  객체지향에서는 클래스에서 인스턴스를 생성하여 인스턴스에 보관 테이블에서는 하나의 \u0026lsquo;Row\u0026rsquo;에 데이터를 저장   관계와 참조라는 의미도 매우 유사함  관계형 데이터베이스는 테이블 사이의 관계를 통하여 구조적인 데이터를 표현 객체지향에서는 참조를 통하여 어떤 객체가 다른 객체들과 어떤 관계를 맺고 있는지를 표현    JPA  \u0026lsquo;Java Persistence API\u0026quot;의 약어 ORM을 Java언어에 맞게 사용하는 스펙 ORM이 더 상위의 개념이다. JPA는 단순한 스펙이기 때문에 해당 스펙을 구현하는 구현체마다 회사의 이름이나 프레임워크의 이름이 다르게 된다. 그중에서 가장 유명한 것이 Hibernate  엔티티 클래스와 JpaRepository Spring Data JPA가 개발에 필요한 것은 단지 두 종류의 코드이다.\n JPA를 통해서 관리하게 되는 객체(이하 엔티티 객체)를 위한 엔티티 클래스 엔티티 객체들을 처리하는 기능을 가진 Repository  repository는 Spring Data JPA에서 제공하는 인터페이스로 설계하는데 스프링 내부에서 자동으로 객체를 생성하고 실행하는 구조이다.    엔티티 클래스 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  @Entity @Table(name = \u0026#34;tbl_memo\u0026#34;) @ToString @Getter @Builder @AllArgsConstructor @NoArgsConstructor public class Memo{ @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long mno; @Coulmn(length = 200, nullable = false) private String memoText; }     @Entity\n 엔티티 클래스는 반드시 @Entity라는 어노테이션을 추가해야한다. 해당 클래스가 엔티티를 위한 클래스라는 것을 의미 해당 클래스의 인스턴스들이 JPA로 관리되는 엔티티 객체라는 것을 의미    @Table\n 데이터베이스상에서 엔티티 클래스를 어떠한 테이블로 생성할 것인지에 대한 정보를 담기 위한 어노테이션 @Table(name = \u0026ldquo;\u0026quot;) 이런 형식으로 이름도 정할 수 있다. 단순히 테이블의 이름 뿐만 아니라 인덱스 등을 생성하는 설정도 가능하다.    @Id, @GeneratedValue\n @Entity가 붙은 클래스는 PK에 해당하는 특정 필드를 @Id로 지정해야만 한다. @Id가 사용자가 입력하는 값을 사용하는 경우가 아니면 자동으로 생성되는 번호를 사용하기 위해 @GeneratedValue라는 어노테이션을 사용한다. (strategy = GenerationType.IDENTITY) 키 생성 전략이라고도 한다.  AUTO - JPA 구현체가 생성 방식을 겨렂 IDENTITY - 사용하는 데이터베이스가 키 생성을 결정 SEQUENCE - 데이터베이스의 sequence를 이용하여 키를 생성, @SequenceGenerator와 같이 사용 TABLE - 키 생성 전용 테이블을 생성해서 키 생성, @TableGenerator와 함께 사용      @Coulmn\n 추가적인 필드가 필요한 경우에도 마찬가지로 어노테이션을 활용한다. nullable, name, length 등을 이용해서 데이터베이스의 칼럼에 필요한 정보를 제공 columnDefinition을 이용하여 기본값도 지정이 가능하다.    @Builder\n 객체 생성하기 위한 어노테이션 @AllArgsConstructor와 @NoArgsConstructor를 같이 사용해야 컴파일 에러가 발생하지 않음    JpaRepository 인터페이스 Sprin Date JPA에는 여러 종류의 인터페이스의 기능을 통해서 JPA 관련 작업을 별도의 코드 없이 처리할수 있게 지원한다. 그 중의 하나가 JpaRepository 인터페이스이다.\n일반적인 기능을 사용할 때는 CrudRepository를 사용하면 되고, 모든 기능을 사용하고 싶다면 JpaRepository를 이용하면 된다. 일반적으로는 JpaRepository를 사용한다.\n1 2 3  public interface SampleRepository extends JpaRepository\u0026lt;Memo,Long\u0026gt; { }    JpaRepository를 사용할 때는 엔티티의 타입정보(Memo 클래스 타입)와 @Id의 타입을 지정한다. 위 처럼 인터페이스의 선언만으로도 자동으로 스프링의 bean으로 등록된다. CRUD  insert 작업 : save(엔티티 객체) select 작업 : findById(키 타입), getOne(키 타입) update 작업 : save(엔티티 객체) delete 작업 : deleteById(키 타입), delete(엔티티 객체) save -\u0026gt; JPA의 구현체가 메모리상에서 객체를 비교하고 없다면 insert, 존재한다면 update를 동작시키는 방식으로 동작    ","description":"","id":4,"section":"posts","tags":null,"title":"JPA 정리","uri":"https://brinst07.github.io/posts/javaspringboot/jpa/"},{"content":"리사이클러뷰  리사이클러뷰는 스피너가 조금 더 확장된 형태이다. 리사이클러뷰도 스피너처럼 목록을 화면에 출력하는데, 레이아웃 매너지를 이용하면 간단한 코드만으로 일반 리스트뷰를 그리드뷰로 바꿀 수 도 있다. 리사이클러뷰처럼 목록을 표시하는 컨테이너들은 표시될 데이터와 아이템 레이아웃을 어댑터에서 연결해주므로 어댑터에서 어떤 아이템 레이아웃을 사용하느냐에 따라 표시되는 모양을 다르게 만들 수 있다.  매커니즘   원하는 액티비티에 리사이클러뷰 만들기\n  리사이클러에 뿌릴 Model(dto) 만들기\n  어댑터 정의하기\n  리사이클러뷰는 리사이클러 어댑터라는 메서드 어댑터를 사용해서 데이터를 연결한다.\n  리사이클러뷰 어댑터는 개별 데이터에 대응하는 뷰홀더 클래스를 사용한다.\n1 2 3 4 5  class customAdapter : RecyclerView.Adapter\u0026lt;ViewHolder\u0026gt;{ override fun onBindViewHolder(viewholder, item){ } }     뷰홀더는 현재 홤녀에 보여지는 개수만큼만 생성되고 목록이 위쪽으로 스크롤 될 경우 가장 위의 뷰홀더를 아래에서 재사용한 후 데이터만 바꿔주기 때문에 앱의 효율이 향상됨.\n    ","description":"","id":5,"section":"posts","tags":null,"title":"RecyclerView","uri":"https://brinst07.github.io/posts/kotlinandroid/recyclerview/"},{"content":"영속성 관리  JPA에서 가장 중요한 2가지  객체와 관계형 DB 매핑하기 - 설계 관련 영속성 컨텍스트 - JPA 내부동작    엔티티 매니저 팩토리와 엔티티 매니저  JPA는 스레드가 하나 생성될 때 마다 EntityManagerFactory에서 EntityManager를 생성한다. EntityManager는 내부적으로 DB 커넥션 풀을 사용해서 DB에 붙인다.  영속성 컨텍스트  엔티티를 영구저장하는 환경이라는 뜻 EntityManger.presist(entity)  persist()를 하면 실제로는 DB에 저장하는 것이 아니라, 영속성 컨텍스트를 통해서 엔티티를 영속화 한다. persist() 시점에는 영속성 컨텍스트에 저장한다. DB저장은 나중임\u0026hellip;.    엔티티의 생명주기  비영속  영속성 컨텍스트와 전혀 관계가 없는 상태   //객체를 생성한 상태 (비영속)\rMember member = new Member();\rmember.setId(\u0026quot;member1);\rmember.setUsername(\u0026quot;회원1\u0026quot;)\r 영속  영속성 컨텍스트에 저장된 상태 엔티티가 영속성 컨텍스트에 의해 관리된다. 이때 DB에 저장 되지 않는다. 영속 상태가 된다고 DB에 쿼리가 날아가지 않는다. 트랜잭션의 커밋 시점에 영속성 컨텍스트에 있는 정보들이 DB에 쿼리로 날아간다.   // 객체를 생성한 상태 (비영속)\rMember member = new Member();\rmember.setId(\u0026quot;member1\u0026quot;);\rmember.setUsername(\u0026quot;회원1\u0026quot;);\rEntityManager entityManager = entityManagerFactory.createEntityManager();\rentityManager.getTransaction().begin();\r// 객체를 저장한 상태 (영속)\rentityManager.persist(member);\r EntityManager.persist(entity)  영속상태가 된다고 바로 DB에 쿼리가 날아가지 않는다. (즉, DB 저장 X)   transaction.commit()  트랜잭션의 commit 시점에 영속성 컨텍스트에 있는 정보들이 DB에 쿼리로 날아간다.     준영속  영속성 컨텍스트에 저장되었다가 분리된 상태 영속성 컨텍스트에서 지운 상태   //회원 엔티티를 영속성 컨텍스트에서 분리, 준영속 상태\rentityManger.detach(member);\r 삭제  삭제된 상태. DB에서도 날린다.   //객체를 삭제한 상태\rentityManager.remove(member);\r  영속성 컨텍스트의 이점  Application과 DB 사이의 중간 계층의 영속성 컨텍스트가 존재하는 이유  버퍼링, 캐싱 등의 이점    1. 1차 캐시   영속성 컨텍스트 내부에는 1차 캐시가 존재한다.\n 1차 캐시를 영속성 컨텍스트라고 이해해도 됨    Map\u0026lt;Key,Value\u0026gt; 로 1차 캐시에 저장된다.\n key : @Id로 선언한 필드값 (DB pk) value : 해당 객체   Member member = new Member();\rmember.setId(\u0026quot;brinst\u0026quot;);\rmember.setUsername(\u0026quot;brinst1\u0026quot;)\r// 영속상태 (Persistence Context에 의해 Entity가 관리되는 상태)\r// DB 저장 X, 1차 캐시에 저장됨\rentityManager.persist(member);\r// 1차 캐시에서 조회\rMember brinst = entityManager.find(Member.class,\u0026quot;brinst\u0026quot;);\r 1차 캐시에 Entity가 있을 때의 이점  조회 entityManager.find()를 하면 DB보다 먼저, 1차 캐시를 조회한다. 1차 캐시에 해당 Entity가 존재하면 바로 반환한다. 1차 캐시에 조회하고자 하는 Entity가 없다면?  DB에서 조회한다. 해당 Entity를 DB에서 꺼내와 1차 캐시에 저장한다. Entity를 다시 반환한다. 이후에 다시 해당 Entity를 조회하면 1차 캐시에 있는 Entity를 반환한다.   그러나, 사실 1차 캐시는 큰 성능 이점을 가지고 있지 않다.  EntityManager는 Transaction 단위로 만들고, 해당 DB Transaction이 끝날 때(사용자의 대한 요청에 대한 비지니스가 끝날 때) 같이 종료된다. 즉, 1차 캐시도 모두 날아가기 때문에 굉장히 짧은 찰나의 순간에만 이득이 있다.(DB의 한 Transaction 안에만 효과가 있다.) 하지만, 비지니스 로직이 굉장히 복잡한 경우에는 효과가 있다.        2. 동일성 보장(Identity) Member a = entityManager.find(Member.class, \u0026quot;member1\u0026quot;);\rMember b = entityManager.find(Member.class, \u0026quot;member1\u0026quot;);\ra == b -\u0026gt; true\r 영속 Entity의 동일성(== 비교)을 보장한다.  즉, \u0026ldquo;==\u0026rdquo; 비교가 true임을 보장한다. member1에 해당하는 Entity를 2번 조회하면 1차 캐시에 의해 같은 Reference로 인식된다. 하나의 Transaction안에서 같은 Entity 비교시 true    3. 엔티티 \u0026ldquo;등록\u0026rdquo; 시 트랜잭션을 지원하는 쓰기 지연(Transactional Write-Behind) EntityManager entityManager = emf.createEntityManager();\rEntityTransaction transaction = entityManager.getTransaction();\r// EntityManager는 데이터 변경 시 트랜잭션을 시작해야 한다.\rtransaction.begin(); // Transaction 시작\rentityManager.persist(memberA);\rentityManager.persist(memberB);\r//이때 까지 Insert SQL을 DB에 보내지 않는다.\r//커밋하는 순간 DB에 INSERT SQL을 보낸다.\rtransaction.commit();\r entityManager.persist()  JPA가 insert SQL을 계속 쌓고 있는 상태   transaction.commit()  커밋하는 시점에 insert SQL을 동시에 DB에 보낸다. 동시에 쿼리들을 보냄(쿼리를 보내는 방식은 동시 or 하나씩 옵션에 따라 다름)   entityManager.persist(memberA)  memberA가 1차 캐시에 저장된다. 1과 동시에 JPA가 Entity를 분석하여 insert Query를 만든다. insert Query를 쓰기 지연 SQL 저장소라는 곳에 쌓는다. DB에 바로 넣지 않고 기다린다.   transaction.commit()  쓰기 지연 SQL 저장소에 쌓여 있는 Query들을 DB로 날린다. (flush)  **flush()**는 1차캐시를 지우지는 않는다. 쿼리들을 DB에 날려서 DB와 싱크를 맞추는 역할을 한다.   flush() 후에 실제 DB Transaction이 커밋된다.    4. 엔티티 \u0026ldquo;수정\u0026quot;시 변경 감지(Dirty Checking) EntityManager em = emf.createEntityManaer();\rEntityTransaction transaction = em.getTransaction();\rtransaction.begin(); //트랜잭션 시작\r//영속 엔티티 조회\rMember memberA = em.find(Member.class, \u0026quot;memberA\u0026quot;);\r//영속 엔티티 데이터 수정\rmemberA.setUsername(\u0026quot;hi\u0026quot;);\rmemberA.setAge(10);\rtransaction.commit();\r Entity 데이터 수정 시 update()나 persist()로 영속성 컨텍스트에 해당 데이터를 업데이트 해달라고 알려줘야 할 필요가 없다. Entity 데이터만 수정하고 commit 하면 알아서 DB에 반영됨 즉, 데이터를 set하면 해당 데이터의 변경을 알아서 감지하여 자동으로 UPDATE Query가 나가는 것이다.  변경 감지(Dirty Checking)  1차 캐시  @Id, Entity, Snapshot (값을 읽어온 최초의 상태) Snapshot : 영속성 컨텍스트에 최초로 값이 들어왔을 때의 상태값을 저장한다.   변경 감지 매커니즘  transaction.commit()을 하면  flush()가 일어날 때 엔티티와 스냅샷을 일일이 비교한다. 변경사항이 있으면 UPDATE Query를 만든다. 해당 UPDATE Query를 쓰기 지연 SQL 저장소에 넣는다. UPDATE Query를 DB에 반영한 후 commit()한다.      5. 엔티티 삭제  Member memberA = em.find(Member.class,\u0026quot;memberA\u0026quot;);\rem.remove(memberA); //엔티티 삭제\r 위의 Entity 수정에서의 매커니즘과 동일 Transaction의 commit 시점에 DELETE Query가 나간다.  플러시(flush)  영속성 컨텍스트의 변경 내용을 DB에 반영하는 것을 말한다. Transaction commit이 일어날 때 flush가 동작하는데, 이때 쓰기 지연 저장소에 쌓아놨던 INSERT, UPDATE, DELETE SQL 들이 DB에 날아간다. -\u0026gt; 영속성 컨텍스트를 비우는 것이 아님 영속성 컨텍스트의 변경사항들과 DB의 상태를 맞추는 작업  플러시는 영속성 컨텍스트의 변경 내용을 DB에 동기화 한다.    플러시의 동작 과정  변경을 감지한다. (Dirty Checking) 수정된 Entity를 쓰기 지연 SQL 저장소에 등록한다. 쓰기 지연 SQL 저장소의 Query를 DB에 전송한다.  flush가 발생한다고 해서 commit이 이루어지는 것이 아니고 flush 다음에 실제 commit이 일어난다. flush가 동작할 수 있는 이뉴는 데이터베이스 트랜잭션(작업 단위)이라는 개념이 있기 때문이다.  트랜잭션이 시작되고 해당, 트랜잭션이 commit 되는 시점 직전에만 동기화(변경 내용을 날림) 해주면 되기 때문에, 그 사이에서 플러시 매커니즘의 동작이 가능한 것이다.      영속성 컨텍스트를 플러시 하는 방법 1. em.flush()을 통한 직접 호출 // 영속 상태(Persistence Context에 의해 Entity가 관리되는 상태)\rMember member = new Member(200L,\u0026quot;A\u0026quot;);\rentityManager.persist(member);\rentityManager.flush(); // 강제 호출(쿼리가 DB에 반영됨)\rtx.commit(); //DB에 insert query가 날아가는 시점(Transaction commit)\r 플러시가 일어나면 1차 캐시가 모두 지워질까?  그대로 남아있음 쓰기 지연 SQL 저장소에 있는 Query들만 DB에 전송까지만 되는 과정일 뿐임    2. 트랜잭션 커밋 시 플러시 자동 호출 3. JPQL 쿼리 실행 시 플러시 자동 호출 em.persist(memberA);\rem.persist(memberB);\rem.persist(memberC);\r// 중간에 JPQL 실행\rquery = entityManager.createQuery(\u0026quot;select m from Member m\u0026quot;,Member.class);\rList\u0026lt;Member\u0026gt; members = query.getResultList();\r member A,B,C 를 영속성 컨텍스트에 저장한 상태에서 바로 조회하면 조회가 될까?  조회가 되지 않는다. DB에 Query로도 날아가야 반영이 될텐데 INSERT Query 자체가 날아가지 않은 상태이다. 이 때문에 JPA의 기본모드는 JPQL 쿼리 실행시 flush()를 자동으로 날린다. -\u0026gt; JPQL 쿼리 실행시 플러시 자동 호출로 인해 위 코드는 조회가 가능하다.    ","description":"","id":6,"section":"posts","tags":null,"title":"JPA 영속성 컨텍스트와 플러시","uri":"https://brinst07.github.io/posts/javaspringboot/jpa%EC%98%81%EC%86%8D%EC%84%B1%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/"},{"content":"다시 살린 블로그 과거에 있던 블로그가 삭제되어서 새롭게 블로그를 다시 만들었다.\n이 블로그에 다시 개발 관련 생각이나, 배운 지식들을 정리하고자 한다.\n2021년도의 계획  스프링부트로 나만의 웹서버 개발하기\n1.1 JPA 숙지하기\n1.2 스프링 부트 숙지하기\n1.3 리액트 숙지하기\n1.4 리액트 숙지 후 더 나아가 리액트 하이브리드 웹앱도 도전해보자 코틀린 + 안드로이드로 나만의 웹을 개발하기\n2.1 firebase 숙지\n2.2 코틀린 문법숙지\n2.3 안드로이드 숙지하기 ios 개발 도전????\n맥북을 구입하게 된다면 ios에도 한번 도전해보자  스프링부트 스터디  계획\n스프링 스터디원들과 함께 JPA react SpringBoot 환경으로 웹사이트 제작 주제\n미정  안드로이드 스터디  계획\n스터디원들과 함께 kotlin을 base로 한 앱을 개발한다. 주제\n토닥토닥 -\u0026gt; 게시판 위주의 앱이 될듯 하다. 기능\n3.1 소셜 로그인\n3.2 firebase를 기반으로 한 CRUD\n3.3 채팅기능\n3.4 결제기능  ","description":"","id":7,"section":"posts","tags":null,"title":"Come Back!!!","uri":"https://brinst07.github.io/posts/etc/test1/"}]