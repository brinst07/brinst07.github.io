[{"content":"cron이란? 특정한 시간, 특정 시간 마다 어떤 작업을 수행하게 해줘야 할때 사용하는 명령어이다.\n스케줄러 같은 개념이라고 생각하면 된다.\n임시파일이나, log 파일 같이 계속 냅두면 처치하기 곤란한 파일들을 cron을 사용하게 쉽게 처리할 수 있다.\nlog같은 파일은 00시에 catlina 파일을 현재 날짜로 복제하고 원본파일은 로그를 삭제하는 방식으로 진행한다면\nlog 파일이 계속 커지지 않고 날짜별로 분류해서 확인할 수 있을 것이다.\n리눅스에서 이러한 작업들을 cron으로 진행한다고 보면 된다.\n또한 백업을 진행해야 한다고 할때 보통 새벽에 진행하게 되는데, cron이 없다면 개발자가 새벽에 출근하여\n이 작업을 진행해야 할것이다. 하지만 cron이 있다면 새벽에 출근하지 않아도 백업을 진행할 수 있다.\ncron의 동작방식, cron 실행 흐름 cron파일이 데몬이기 때문에 부팅시 백그라운드로 실행된다.\ncron 동작방식을 보면 cron 데몬(crond)가 crontab을 참조하고 있다.\ncron 데몬은 어떤 task를 언제 수행할지 crontab에서 찾아서 실행한다.\ncron 데몬은 시스템 스케줄러 정보뿐만 아니라 각각 사용자가 설정한 작업 예약 정보도 crontab에서 확인한다.\ncron의 정규 표현식    필드명 값의 허용 범위 허용된 특수문자     초(Seconds) 0~59 , - * /   분 (Minutes) 0~59 , - * /   시 (Hours) 0~23 , - * /   일 (Day) 1~31 , - * ? / L W   월 (Month) 1 ~ 12 or JAN ~ DEC , - * /   요일 (Week) 0 ~ 6 or SUN ~ SAT , - * ? / L #   연도 (Year) empty or 1970 ~ 2099 , - * /    Cron 표현식 - 특수문자 ● * : 모든 값을 뜻합니다.\n● ? : 특정한 값이 없음을 뜻합니다.\n● - : 범위를 뜻합니다. (예) 월요일에서 수요일까지는 MON-WED로 표현\n● , : 특별한 값일 때만 동작 (예) 월,수,금 MON,WED,FRI\n● / : 시작시간 / 단위 (예) 0분부터 매 5분 0/5\n● L : 일에서 사용하면 마지막 일, 요일에서는 마지막 요일(토요일)\n● W : 가장 가까운 평일 (예) 15W는 15일에서 가장 가까운 평일 (월 ~ 금)을 찾음\n● # : 몇째주의 무슨 요일을 표현 (예) 3#2 : 2번째주 수요일\ncrontab 파일의 7필드 m h dom mon dow user command    필드 설정 값 및 내용     m 분을 나타내고, 0~59로 설정한다.   h 시을 나타내고, 0~23으로 설정한다.   dom 날을 나타내고, 1~31로 설정한다.   mon 월을 나타내고, 1~12로 설정한다.   dow 요일을 나타내고, 0~7로 설정한다. 0과 7은 일요일에 해당하고 1은 월요일임   user user-name 사용자 이름   command 실행할 명령어를 기입한다. 명령어 앞에 사용자 이름을 써도 된다.     \u0026lsquo;*\u0026rsquo; : 각 필드 자리에 * 기호가 오면 해당 필드의 모든 값을 의미한다. \u0026lsquo;-\u0026rsquo; : 그 사이의 모든 값 \u0026lsquo;,\u0026rsquo; : 지정한 모든 값을 의미(불규칙한 값 지정시 주로 사용) \u0026lsquo;/\u0026rsquo; : \u0026lsquo;/\u0026lsquo;는 연결된 설정 값 범위에서 특정 주기로 나눌 때 사용한다.  Cron 예시 01 * * * * root run-parts /etc/cron.hourly #매일 매시 1분에 root 권한으로 /etc/cron.hourly 내 모든 스크립트를 실행한다.\r02 4 * * * root run-parts /etc/cron.daily # 매일 새벽 4시 2분에 /etc/cron.daily 내 모든 작업을 실행한다.\r# 2분으로 한 것은 매 1분에는 시간별 작업이 실행되기 때문이다.\r22 4 * * 0 root run-parts /etc/cron.weekly # 매주 일요일(0) 4시 22분에 주간 작업들을 실행한다.\r42 4 1 * * root run-parts /etc/cron.monthly # 매월 1일 4시 42분에 월간 작업들을 실행한다.\rCronMaker 참고 사이트 http://www.cronmaker.com/;jsessionid=node068maia8exxmw1ia839g15hrpk46275.node0?0\nShell Script  스크립트 : 텍스트 형식으로 저장되는 프로그램으로서 한줄씩 순차적으로 읽어 실행되도록 작성된 프로그램  일반적으로 인터프리트 방식으로 동작하는 컴파일되지 않은 프로그램   Shell Script : 운영체제의 쉘 즉 bash, ksh, csh 등이 읽어 실행해주는 스크립트 언어  환경  Linux 기반 시스템 Bash shell(/bin/bash)  작성방법 1 2 3  #!/bin/bash  하단에 스크립트를 작성한다.   쉘 스크립트 실행방법 ./shell_test.sh\r기본 문법  출력 1 2 3  #! /bin/bash  echo \u0026#34;hello~ script\u0026#34;     위 쉘 스크립트를 실행하면 hello script 한줄을 실행한다.\n  주석 : #\n  변수선언\n =를 이용하여 선언하고 $를 이용해서 사용 =는 공백없이 붙여써야한다. 지역변수에는 local을 붙인다. \u0026ldquo;\u0026ldquo;로 감싸서 사용하면 더 안전하다. 문자열에 공백도 포함해서 값을 이용 할 수 있기 때문에  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #!/bin/bash # 변수 선언 test=\u0026#34;abc\u0026#34; num=100 #변수 사용하기 및 출력 echo ${test} echo ${num} echo \u0026#34;${test}\u0026#34; echo \u0026#34;${num}\u0026#34; #지역변수 local local_var=\u0026#34;local var\u0026#34; #변수가 선언되지 않았을 때 기본값을 지정하며 사용하는 방법 defalut_var=${default_var=\u0026#34;temp\u0026#34;}     배열\n 배열의 인덱스는 0부터 시작함 배열이름[@]는 배열의 모든 원소를 의미한다. 배열의 원소 추가 시는 += 연산자를 사용한다. 배열에서 원소를 삭제시  /를 사용해 해당 문자열 부분이 있으면 삭제, 삭제하고자 하는 문자나 문자열이 포함되어 있는 부분을 삭제 unset을 이용해 삭제    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  #!/bin/bash arr_test=(\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;) echo \u0026#34;${arr_test[1]}\u0026#34; echo \u0026#34;${arr_test[@]}\u0026#34; arr_test+=(\u0026#34;3\u0026#34;,\u0026#34;4\u0026#34;) remove_element=(3) arr_test=(\u0026#34;${arr_test[@]/$remove_element}\u0026#34;) for i in ${!arr_test[@]}; do if [ ${arr_test[i]} = ${remove_element} ]; then # Use unset unset arr_test[i] fi done     조건문\n if[조건]; then\u0026hellip; elif[조건]; then\u0026hellip;else 를 사용한다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  #!/bin/bash # Numeric if statement test_num=5 if [ \u0026#34;${test_num}\u0026#34; -eq 2 ]; then echo \u0026#34;number is 2\u0026#34; elif [ \u0026#34;${test_num}\u0026#34; -eq 3 ]; then echo \u0026#34;number is 3\u0026#34; else echo \u0026#34;number is not 2 or 3\u0026#34; fi # Numeric if statement test_num=5 if (( ${test_num} \u0026gt; 3 )); then echo \u0026#34;number is greater than 3\u0026#34; else echo \u0026#34;number is not greater than 3\u0026#34; fi # String if statement test_str=\u0026#34;test\u0026#34; if [ \u0026#34;${test_str}\u0026#34; = \u0026#34;test\u0026#34; ]; then echo \u0026#34;test_str is test\u0026#34; else echo \u0026#34;test_str is not test\u0026#34; fi     반복문\n while 문의 사용  1 2 3 4 5 6 7  #!/bin/bash cnt=0 while (( \u0026#34;${cnt}\u0026#34; \u0026lt; 5 )); do echo \u0026#34;${cnt}\u0026#34; (( cnt = \u0026#34;${cnt}\u0026#34; + 1 )) # 숫자와 변수의 연산은 (())가 필요합니다. done     for문의 사용법\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  #!/bin/bash arr_num=(1 2 3 4 5 6 7) # 배열에 @는 모든 원소를 뜻합니다. for i in ${arr_num[@]}; do printf $i done echo for (( i = 0; i \u0026lt; 10; i++)); do printf $i done echo     ","description":"","id":0,"section":"posts","tags":null,"title":"cron 과 shellscript","uri":"https://brinst07.github.io/posts/linuxsever/cronshellscript/"},{"content":"JPA란?? Java 언어를 통해서 데이터베이스와 같은 영속 계층을 처리하고자 하는 스펙\nORM과 JPA ORM  객체지향과 관련이 있음 \u0026lsquo;객체지향 패러다임을 관계형 데이터베이스에 보존하는 기술\u0026rsquo; \u0026lsquo;객체지향 패러다임을 관계형 패러다임으로 매핑해주는 개념\u0026rsquo; 관계형 데이터베이스의 테이블을 설계하여 데이터를 보관하는 틀을 만든다는 의미에서 클래스와 상당히 유사함\njava\rsql\r\r1 2 3 4 5  public class Member{ private String id; private String pw; private String name; }   \r\r1 2 3 4  Member id -\u0026gt; varchar2(50) pw -\u0026gt; varchar2(50) name -\u0026gt; varchar2(100)   \r\r\r\r'use strict';\rvar containerId = JSON.parse(\"\\\"a2b3ccb3baa0201e\\\"\");\rvar containerElem = document.getElementById(containerId);\rvar codetabLinks = null;\rvar codetabContents = null;\rvar ids = [];\rif (containerElem) {\rcodetabLinks = containerElem.querySelectorAll('.codetab__link');\rcodetabContents = containerElem.querySelectorAll('.codetab__content');\r}\rfor (var i = 0; i 0) {\rcodetabContents[0].style.display = 'block';\r}\r   클래스와 테이블이 유사하듯이 \u0026lsquo;인스턴스\u0026rsquo;와 \u0026lsquo;Row\u0026rsquo;도 상당히 유사함  객체지향에서는 클래스에서 인스턴스를 생성하여 인스턴스에 보관 테이블에서는 하나의 \u0026lsquo;Row\u0026rsquo;에 데이터를 저장   관계와 참조라는 의미도 매우 유사함  관계형 데이터베이스는 테이블 사이의 관계를 통하여 구조적인 데이터를 표현 객체지향에서는 참조를 통하여 어떤 객체가 다른 객체들과 어떤 관계를 맺고 있는지를 표현    JPA  \u0026lsquo;Java Persistence API\u0026quot;의 약어 ORM을 Java언어에 맞게 사용하는 스펙 ORM이 더 상위의 개념이다. JPA는 단순한 스펙이기 때문에 해당 스펙을 구현하는 구현체마다 회사의 이름이나 프레임워크의 이름이 다르게 된다. 그중에서 가장 유명한 것이 Hibernate  엔티티 클래스와 JpaRepository Spring Data JPA가 개발에 필요한 것은 단지 두 종류의 코드이다.\n JPA를 통해서 관리하게 되는 객체(이하 엔티티 객체)를 위한 엔티티 클래스 엔티티 객체들을 처리하는 기능을 가진 Repository  repository는 Spring Data JPA에서 제공하는 인터페이스로 설계하는데 스프링 내부에서 자동으로 객체를 생성하고 실행하는 구조이다.    엔티티 클래스 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  @Entity @Table(name = \u0026#34;tbl_memo\u0026#34;) @ToString @Getter @Builder @AllArgsConstructor @NoArgsConstructor public class Memo{ @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long mno; @Coulmn(length = 200, nullable = false) private String memoText; }     @Entity\n 엔티티 클래스는 반드시 @Entity라는 어노테이션을 추가해야한다. 해당 클래스가 엔티티를 위한 클래스라는 것을 의미 해당 클래스의 인스턴스들이 JPA로 관리되는 엔티티 객체라는 것을 의미    @Table\n 데이터베이스상에서 엔티티 클래스를 어떠한 테이블로 생성할 것인지에 대한 정보를 담기 위한 어노테이션 @Table(name = \u0026ldquo;\u0026quot;) 이런 형식으로 이름도 정할 수 있다. 단순히 테이블의 이름 뿐만 아니라 인덱스 등을 생성하는 설정도 가능하다.    @Id, @GeneratedValue\n @Entity가 붙은 클래스는 PK에 해당하는 특정 필드를 @Id로 지정해야만 한다. @Id가 사용자가 입력하는 값을 사용하는 경우가 아니면 자동으로 생성되는 번호를 사용하기 위해 @GeneratedValue라는 어노테이션을 사용한다. (strategy = GenerationType.IDENTITY) 키 생성 전략이라고도 한다.  AUTO - JPA 구현체가 생성 방식을 겨렂 IDENTITY - 사용하는 데이터베이스가 키 생성을 결정 SEQUENCE - 데이터베이스의 sequence를 이용하여 키를 생성, @SequenceGenerator와 같이 사용 TABLE - 키 생성 전용 테이블을 생성해서 키 생성, @TableGenerator와 함께 사용      @Coulmn\n 추가적인 필드가 필요한 경우에도 마찬가지로 어노테이션을 활용한다. nullable, name, length 등을 이용해서 데이터베이스의 칼럼에 필요한 정보를 제공 columnDefinition을 이용하여 기본값도 지정이 가능하다.    @Builder\n 객체 생성하기 위한 어노테이션 @AllArgsConstructor와 @NoArgsConstructor를 같이 사용해야 컴파일 에러가 발생하지 않음    JpaRepository 인터페이스 Sprin Date JPA에는 여러 종류의 인터페이스의 기능을 통해서 JPA 관련 작업을 별도의 코드 없이 처리할수 있게 지원한다. 그 중의 하나가 JpaRepository 인터페이스이다.\n일반적인 기능을 사용할 때는 CrudRepository를 사용하면 되고, 모든 기능을 사용하고 싶다면 JpaRepository를 이용하면 된다. 일반적으로는 JpaRepository를 사용한다.\n1 2 3  public interface SampleRepository extends JpaRepository\u0026lt;Memo,Long\u0026gt; { }    JpaRepository를 사용할 때는 엔티티의 타입정보(Memo 클래스 타입)와 @Id의 타입을 지정한다. 위 처럼 인터페이스의 선언만으로도 자동으로 스프링의 bean으로 등록된다. CRUD  insert 작업 : save(엔티티 객체) select 작업 : findById(키 타입), getOne(키 타입) update 작업 : save(엔티티 객체) delete 작업 : deleteById(키 타입), delete(엔티티 객체) save -\u0026gt; JPA의 구현체가 메모리상에서 객체를 비교하고 없다면 insert, 존재한다면 update를 동작시키는 방식으로 동작    ","description":"","id":1,"section":"posts","tags":null,"title":"JPA 정리","uri":"https://brinst07.github.io/posts/javaspringboot/jpa/"},{"content":"리사이클러뷰  리사이클러뷰는 스피너가 조금 더 확장된 형태이다. 리사이클러뷰도 스피너처럼 목록을 화면에 출력하는데, 레이아웃 매너지를 이용하면 간단한 코드만으로 일반 리스트뷰를 그리드뷰로 바꿀 수 도 있다. 리사이클러뷰처럼 목록을 표시하는 컨테이너들은 표시될 데이터와 아이템 레이아웃을 어댑터에서 연결해주므로 어댑터에서 어떤 아이템 레이아웃을 사용하느냐에 따라 표시되는 모양을 다르게 만들 수 있다.  매커니즘   원하는 액티비티에 리사이클러뷰 만들기\n  리사이클러에 뿌릴 Model(dto) 만들기\n  어댑터 정의하기\n  리사이클러뷰는 리사이클러 어댑터라는 메서드 어댑터를 사용해서 데이터를 연결한다.\n  리사이클러뷰 어댑터는 개별 데이터에 대응하는 뷰홀더 클래스를 사용한다.\n1 2 3 4 5  class customAdapter : RecyclerView.Adapter\u0026lt;ViewHolder\u0026gt;{ override fun onBindViewHolder(viewholder, item){ } }     뷰홀더는 현재 홤녀에 보여지는 개수만큼만 생성되고 목록이 위쪽으로 스크롤 될 경우 가장 위의 뷰홀더를 아래에서 재사용한 후 데이터만 바꿔주기 때문에 앱의 효율이 향상됨.\n    ","description":"","id":2,"section":"posts","tags":null,"title":"RecyclerView","uri":"https://brinst07.github.io/posts/kotlinandroid/recyclerview/"},{"content":"영속성 관리  JPA에서 가장 중요한 2가지  객체와 관계형 DB 매핑하기 - 설계 관련 영속성 컨텍스트 - JPA 내부동작    엔티티 매니저 팩토리와 엔티티 매니저  JPA는 스레드가 하나 생성될 때 마다 EntityManagerFactory에서 EntityManager를 생성한다. EntityManager는 내부적으로 DB 커넥션 풀을 사용해서 DB에 붙인다.  영속성 컨텍스트  엔티티를 영구저장하는 환경이라는 뜻 EntityManger.presist(entity)  persist()를 하면 실제로는 DB에 저장하는 것이 아니라, 영속성 컨텍스트를 통해서 엔티티를 영속화 한다. persist() 시점에는 영속성 컨텍스트에 저장한다. DB저장은 나중임\u0026hellip;.    엔티티의 생명주기  비영속  영속성 컨텍스트와 전혀 관계가 없는 상태   //객체를 생성한 상태 (비영속)\rMember member = new Member();\rmember.setId(\u0026quot;member1);\rmember.setUsername(\u0026quot;회원1\u0026quot;)\r 영속  영속성 컨텍스트에 저장된 상태 엔티티가 영속성 컨텍스트에 의해 관리된다. 이때 DB에 저장 되지 않는다. 영속 상태가 된다고 DB에 쿼리가 날아가지 않는다. 트랜잭션의 커밋 시점에 영속성 컨텍스트에 있는 정보들이 DB에 쿼리로 날아간다.   // 객체를 생성한 상태 (비영속)\rMember member = new Member();\rmember.setId(\u0026quot;member1\u0026quot;);\rmember.setUsername(\u0026quot;회원1\u0026quot;);\rEntityManager entityManager = entityManagerFactory.createEntityManager();\rentityManager.getTransaction().begin();\r// 객체를 저장한 상태 (영속)\rentityManager.persist(member);\r EntityManager.persist(entity)  영속상태가 된다고 바로 DB에 쿼리가 날아가지 않는다. (즉, DB 저장 X)   transaction.commit()  트랜잭션의 commit 시점에 영속성 컨텍스트에 있는 정보들이 DB에 쿼리로 날아간다.     준영속  영속성 컨텍스트에 저장되었다가 분리된 상태 영속성 컨텍스트에서 지운 상태   //회원 엔티티를 영속성 컨텍스트에서 분리, 준영속 상태\rentityManger.detach(member);\r 삭제  삭제된 상태. DB에서도 날린다.   //객체를 삭제한 상태\rentityManager.remove(member);\r  영속성 컨텍스트의 이점  Application과 DB 사이의 중간 계층의 영속성 컨텍스트가 존재하는 이유  버퍼링, 캐싱 등의 이점    1. 1차 캐시   영속성 컨텍스트 내부에는 1차 캐시가 존재한다.\n 1차 캐시를 영속성 컨텍스트라고 이해해도 됨    Map\u0026lt;Key,Value\u0026gt; 로 1차 캐시에 저장된다.\n key : @Id로 선언한 필드값 (DB pk) value : 해당 객체   Member member = new Member();\rmember.setId(\u0026quot;brinst\u0026quot;);\rmember.setUsername(\u0026quot;brinst1\u0026quot;)\r// 영속상태 (Persistence Context에 의해 Entity가 관리되는 상태)\r// DB 저장 X, 1차 캐시에 저장됨\rentityManager.persist(member);\r// 1차 캐시에서 조회\rMember brinst = entityManager.find(Member.class,\u0026quot;brinst\u0026quot;);\r 1차 캐시에 Entity가 있을 때의 이점  조회 entityManager.find()를 하면 DB보다 먼저, 1차 캐시를 조회한다. 1차 캐시에 해당 Entity가 존재하면 바로 반환한다. 1차 캐시에 조회하고자 하는 Entity가 없다면?  DB에서 조회한다. 해당 Entity를 DB에서 꺼내와 1차 캐시에 저장한다. Entity를 다시 반환한다. 이후에 다시 해당 Entity를 조회하면 1차 캐시에 있는 Entity를 반환한다.   그러나, 사실 1차 캐시는 큰 성능 이점을 가지고 있지 않다.  EntityManager는 Transaction 단위로 만들고, 해당 DB Transaction이 끝날 때(사용자의 대한 요청에 대한 비지니스가 끝날 때) 같이 종료된다. 즉, 1차 캐시도 모두 날아가기 때문에 굉장히 짧은 찰나의 순간에만 이득이 있다.(DB의 한 Transaction 안에만 효과가 있다.) 하지만, 비지니스 로직이 굉장히 복잡한 경우에는 효과가 있다.        2. 동일성 보장(Identity) Member a = entityManager.find(Member.class, \u0026quot;member1\u0026quot;);\rMember b = entityManager.find(Member.class, \u0026quot;member1\u0026quot;);\ra == b -\u0026gt; true\r 영속 Entity의 동일성(== 비교)을 보장한다.  즉, \u0026ldquo;==\u0026rdquo; 비교가 true임을 보장한다. member1에 해당하는 Entity를 2번 조회하면 1차 캐시에 의해 같은 Reference로 인식된다. 하나의 Transaction안에서 같은 Entity 비교시 true    3. 엔티티 \u0026ldquo;등록\u0026rdquo; 시 트랜잭션을 지원하는 쓰기 지연(Transactional Write-Behind) EntityManager entityManager = emf.createEntityManager();\rEntityTransaction transaction = entityManager.getTransaction();\r// EntityManager는 데이터 변경 시 트랜잭션을 시작해야 한다.\rtransaction.begin(); // Transaction 시작\rentityManager.persist(memberA);\rentityManager.persist(memberB);\r//이때 까지 Insert SQL을 DB에 보내지 않는다.\r//커밋하는 순간 DB에 INSERT SQL을 보낸다.\rtransaction.commit();\r entityManager.persist()  JPA가 insert SQL을 계속 쌓고 있는 상태   transaction.commit()  커밋하는 시점에 insert SQL을 동시에 DB에 보낸다. 동시에 쿼리들을 보냄(쿼리를 보내는 방식은 동시 or 하나씩 옵션에 따라 다름)   entityManager.persist(memberA)  memberA가 1차 캐시에 저장된다. 1과 동시에 JPA가 Entity를 분석하여 insert Query를 만든다. insert Query를 쓰기 지연 SQL 저장소라는 곳에 쌓는다. DB에 바로 넣지 않고 기다린다.   transaction.commit()  쓰기 지연 SQL 저장소에 쌓여 있는 Query들을 DB로 날린다. (flush)  **flush()**는 1차캐시를 지우지는 않는다. 쿼리들을 DB에 날려서 DB와 싱크를 맞추는 역할을 한다.   flush() 후에 실제 DB Transaction이 커밋된다.    4. 엔티티 \u0026ldquo;수정\u0026quot;시 변경 감지(Dirty Checking) EntityManager em = emf.createEntityManaer();\rEntityTransaction transaction = em.getTransaction();\rtransaction.begin(); //트랜잭션 시작\r//영속 엔티티 조회\rMember memberA = em.find(Member.class, \u0026quot;memberA\u0026quot;);\r//영속 엔티티 데이터 수정\rmemberA.setUsername(\u0026quot;hi\u0026quot;);\rmemberA.setAge(10);\rtransaction.commit();\r Entity 데이터 수정 시 update()나 persist()로 영속성 컨텍스트에 해당 데이터를 업데이트 해달라고 알려줘야 할 필요가 없다. Entity 데이터만 수정하고 commit 하면 알아서 DB에 반영됨 즉, 데이터를 set하면 해당 데이터의 변경을 알아서 감지하여 자동으로 UPDATE Query가 나가는 것이다.  변경 감지(Dirty Checking)  1차 캐시  @Id, Entity, Snapshot (값을 읽어온 최초의 상태) Snapshot : 영속성 컨텍스트에 최초로 값이 들어왔을 때의 상태값을 저장한다.   변경 감지 매커니즘  transaction.commit()을 하면  flush()가 일어날 때 엔티티와 스냅샷을 일일이 비교한다. 변경사항이 있으면 UPDATE Query를 만든다. 해당 UPDATE Query를 쓰기 지연 SQL 저장소에 넣는다. UPDATE Query를 DB에 반영한 후 commit()한다.      5. 엔티티 삭제  Member memberA = em.find(Member.class,\u0026quot;memberA\u0026quot;);\rem.remove(memberA); //엔티티 삭제\r 위의 Entity 수정에서의 매커니즘과 동일 Transaction의 commit 시점에 DELETE Query가 나간다.  플러시(flush)  영속성 컨텍스트의 변경 내용을 DB에 반영하는 것을 말한다. Transaction commit이 일어날 때 flush가 동작하는데, 이때 쓰기 지연 저장소에 쌓아놨던 INSERT, UPDATE, DELETE SQL 들이 DB에 날아간다. -\u0026gt; 영속성 컨텍스트를 비우는 것이 아님 영속성 컨텍스트의 변경사항들과 DB의 상태를 맞추는 작업  플러시는 영속성 컨텍스트의 변경 내용을 DB에 동기화 한다.    플러시의 동작 과정  변경을 감지한다. (Dirty Checking) 수정된 Entity를 쓰기 지연 SQL 저장소에 등록한다. 쓰기 지연 SQL 저장소의 Query를 DB에 전송한다.  flush가 발생한다고 해서 commit이 이루어지는 것이 아니고 flush 다음에 실제 commit이 일어난다. flush가 동작할 수 있는 이뉴는 데이터베이스 트랜잭션(작업 단위)이라는 개념이 있기 때문이다.  트랜잭션이 시작되고 해당, 트랜잭션이 commit 되는 시점 직전에만 동기화(변경 내용을 날림) 해주면 되기 때문에, 그 사이에서 플러시 매커니즘의 동작이 가능한 것이다.      영속성 컨텍스트를 플러시 하는 방법 1. em.flush()을 통한 직접 호출 // 영속 상태(Persistence Context에 의해 Entity가 관리되는 상태)\rMember member = new Member(200L,\u0026quot;A\u0026quot;);\rentityManager.persist(member);\rentityManager.flush(); // 강제 호출(쿼리가 DB에 반영됨)\rtx.commit(); //DB에 insert query가 날아가는 시점(Transaction commit)\r 플러시가 일어나면 1차 캐시가 모두 지워질까?  그대로 남아있음 쓰기 지연 SQL 저장소에 있는 Query들만 DB에 전송까지만 되는 과정일 뿐임    2. 트랜잭션 커밋 시 플러시 자동 호출 3. JPQL 쿼리 실행 시 플러시 자동 호출 em.persist(memberA);\rem.persist(memberB);\rem.persist(memberC);\r// 중간에 JPQL 실행\rquery = entityManager.createQuery(\u0026quot;select m from Member m\u0026quot;,Member.class);\rList\u0026lt;Member\u0026gt; members = query.getResultList();\r member A,B,C 를 영속성 컨텍스트에 저장한 상태에서 바로 조회하면 조회가 될까?  조회가 되지 않는다. DB에 Query로도 날아가야 반영이 될텐데 INSERT Query 자체가 날아가지 않은 상태이다. 이 때문에 JPA의 기본모드는 JPQL 쿼리 실행시 flush()를 자동으로 날린다. -\u0026gt; JPQL 쿼리 실행시 플러시 자동 호출로 인해 위 코드는 조회가 가능하다.    ","description":"","id":3,"section":"posts","tags":null,"title":"JPA 영속성 컨텍스트와 플러시","uri":"https://brinst07.github.io/posts/javaspringboot/jpa%EC%98%81%EC%86%8D%EC%84%B1%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/"},{"content":"다시 살린 블로그 과거에 있던 블로그가 삭제되어서 새롭게 블로그를 다시 만들었다.\n이 블로그에 다시 개발 관련 생각이나, 배운 지식들을 정리하고자 한다.\n2021년도의 계획  스프링부트로 나만의 웹서버 개발하기\n1.1 JPA 숙지하기\n1.2 스프링 부트 숙지하기\n1.3 리액트 숙지하기\n1.4 리액트 숙지 후 더 나아가 리액트 하이브리드 웹앱도 도전해보자 코틀린 + 안드로이드로 나만의 웹을 개발하기\n2.1 firebase 숙지\n2.2 코틀린 문법숙지\n2.3 안드로이드 숙지하기 ios 개발 도전????\n맥북을 구입하게 된다면 ios에도 한번 도전해보자  스프링부트 스터디  계획\n스프링 스터디원들과 함께 JPA react SpringBoot 환경으로 웹사이트 제작 주제\n미정  안드로이드 스터디  계획\n스터디원들과 함께 kotlin을 base로 한 앱을 개발한다. 주제\n토닥토닥 -\u0026gt; 게시판 위주의 앱이 될듯 하다. 기능\n3.1 소셜 로그인\n3.2 firebase를 기반으로 한 CRUD\n3.3 채팅기능\n3.4 결제기능  ","description":"","id":4,"section":"posts","tags":null,"title":"Come Back!!!","uri":"https://brinst07.github.io/posts/etc/test1/"}]